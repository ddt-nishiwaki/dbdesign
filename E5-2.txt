正規化されたテーブルに対するSQL

要件1) 商品分類ごとの商品数。結果には分類名を含むものとする
要件2) 支社/支店別の取り扱い商品の一覧。結果には支社名、支店名、商品名を含むものとする。
要件3) 最も取り扱い商品数が多い支店の支店コードと商品数。

上記要件を見たすSQL文に対して,パフォーマンス向上を実施します。
本章で学んだ非正規化を含むテーブル構成の変更による方法を考えてください。


(支店商品)
支社コード	支店コード	商品コード
--------------------------------
001			01			001
001			01			002
001			01			003
001			02			002
001			02			003
001			02			004
001			02			005
001			02			006
002			01			001
002			01			002
002			02			007
002			02			008


(商品)
商品コード	商品名		商品分類コード
-------------------------------------
001			石鹸　　		C1
002			タオル　		C1
003			歯ブラシ		C1
003			歯ブラシ		C1
004			コップ　		C1
005			箸　　　		C2
006			スプーン		C2
007			雑誌　　		C3
008			爪切り　		C4


(商品分類)
商品分類コード	分類名
------------------------
C1				水洗用品
C2				食器
C3				書籍
C4				日用雑貨


(支社)
*支社コード	支社名
--------------------
001			東京
002			大阪


(支店)
*支社コード	*支店コード	支店名
----------------------------------
001			01			渋谷
001			02			八重洲
002			01			界
002			02			豊中


回答：

SQL文で処理時間がかかる命令として「結合」処理があります。
これを極力排除するようにテーブル構成の変更を行います。

また次のことに当てはまる場合は対処するとパフォーマンス改善につながるので検討します
・サマリーデータを冗長に保持すると正規形に違反するが、検索を高速化できる
・選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる



要件1) 商品分類ごとの商品数。結果には分類名を含むものとする

	SELECT
		category.分類名,
		COUNT(*) AS 商品数
	FROM
		商品 AS product
	LEFT JOIN
		商品分類 AS category
	ON
		product.商品分類コード = category.商品分類コード
	GROUP BY
		商品分類コード
	;

	このSQL文で行われている結合の理由を考えます。
	理由は商品数を集計するために商品テーブルが必要で、かつ、商品分類毎に結果をまとめる必要があるからです。
	これを改善するようにテーブル構造を修正します。
	'商品数'は各レコードをカウントした結果(サマリーデータ)なのでこれを冗長に保持できないか考えます。
	データが必要なのは商品分類毎なので商品分類テーブルに商品数フィールドを追加すると、結合する理由もなくなるためSQLが簡潔になり検索の高速化が期待できます。

	( 商品分類テーブルに商品数を追加 )
	+-----------------+--------------+-----------+
	| 商品コード       | 商品名        | 商品数     |
	+-----------------+--------------+-----------+
	| C1              | 水洗用品      |         5 |
	| C2              | 食器　　      |         2 |
	| C3              | 書籍　　      |         1 |
	| C4              | 日用雑貨      |         1 |
	+-----------------+--------------+-----------+


要件2) 支社/支店別の取り扱い商品の一覧。結果には支社名、支店名、商品名を含むものとする。

	SELECT
		支社.支社名,
		支店.支店名,
		商品.商品名
	FROM
		(
			(
				支店商品
			INNER JOIN
				支店
			ON
				支店.支社コード = 支店商品.支社コード
			AND
				支店.支店コード = 支店商品.支店コード
			)
		INNER JOIN
			支社
		ON
			支社.支社コード = 支店商品.支社コード
		)
	INNER JOIN
		商品
	ON
		支店商品.商品コード = 商品.商品コード
	;

	このSQL文では結合命令を3回使用しています。理由は求める情報がまとまっている
支店商品テーブルが実際のデータではなくキーとなる値だけで構成されているテーブルであるためです。
解決策としては求める情報(名前)のフィールドを追加することが考えられます。

	(支店商品テーブルに結合で得ていた情報をフィールドにあらかじめ追加する)
	+-----------------+-----------------+-----------------+-----------+-----------+--------------+
	| 支店コード       | 支社コード        | 商品コード       | 支店名     | 支社名     | 商品名        |
	+-----------------+-----------------+-----------------+-----------+-----------+--------------+
	| 01              | 001             | 001             | 渋谷　     | 東京      | 石鹸　　       |
	| 01              | 001             | 002             | 渋谷　     | 東京      | タオル　       |
	| 01              | 001             | 003             | 渋谷　     | 東京      | 歯ブラシ       |
	| 02              | 001             | 002             | 八重洲     | 東京      | タオル　       |
	| 02              | 001             | 003             | 八重洲     | 東京      | 歯ブラシ       |
	| 02              | 001             | 004             | 八重洲     | 東京      | コップ　       |
	| 02              | 001             | 005             | 八重洲     | 東京      | 箸　　　       |
	| 02              | 001             | 006             | 八重洲     | 東京      | スプーン       |
	| 01              | 002             | 001             | 界　　     | 大阪      | 石鹸　　       |
	| 01              | 002             | 002             | 界　　     | 大阪      | タオル　       |
	| 02              | 002             | 007             | 豊中　     | 大阪      | 雑誌　　       |
	| 02              | 002             | 008             | 豊中　     | 大阪      | 爪切り　       |
	+-----------------+-----------------+-----------------+-----------+-----------+--------------+


要件3) 最も取り扱い商品数が多い支店の支店コードと商品数。

	SELECT DISTINCT
		支店.商品コード AS 支店コード,
		COUNT(*) AS 最大商品数
	FROM
		(
			(
				支店商品
			INNER JOIN
				支店
			ON
				支店.支社コード = 支店商品.支社コード
			AND
				支店.商品コード = 支店商品.商品コード
			)
		INNER JOIN
			支社
		ON
			支社.支社コード = 支店商品.支社コード
		)
	INNER JOIN
		商品
	ON
		支店商品.商品コード = 商品.商品コード
	GROUP BY
		支店.支店名
	HAVING
		COUNT(*) =
		(
			SELECT
				MAX( number_of_product )
			FROM
			(
				SELECT DISTINCT
					COUNT(*) AS number_of_product
				FROM
					(
						(
							支店商品
						INNER JOIN
							支店
						ON
							支店.支社コード = 支店商品.支社コード
						AND
							支店.商品コード = 支店商品.商品コード
						)
					INNER JOIN
						支社
					ON
						支社.支社コード = 支店商品.支社コード
					)
				INNER JOIN
					商品
				ON
					支店商品.商品コード = 商品.商品コード
				GROUP BY
					支店.支店名
			) AS product_count
		)
	;

	要件2で名前の情報を追加した支店情報テーブルがあればこのSQL文ももう少しシンプルになりますが、「COUNTの結果に対してMAXの値をとる
」ために同じテーブルを2回取得している部分に無駄がありそうです。
	「選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる」を実践するのであれば、COUNTで取得している集計結果を支店テーブルに追加するとMAXのみで要件を満たせます。

	( 支店テーブルに商品数フィールドを追加する )
	+------------+----------+-----------+----------+
	| 支社コード  | 支店コード | 支店名     |商品数     |
	+------------+----------+-----------+----------+
	| 001        | 01       | 渋谷　     | 4        |
	| 001        | 02       | 八重洲     | 6        |
	| 002        | 01       | 界　　     | 2        |
	| 002        | 02       | 豊中　     | 2        |
	+------------+----------+-----------+----------+



