インデックスの再編成

「B-tree インデックスに関する巣の他の注意事項」で、B-treeインデックスは更新が発生することで時間とともに構造が崩れ、性能が劣化することを証明しました。これを防止するためにインデックスの再編成が必要になります。再編成を実施するための具体的な方法を、DBMSごとに調べてください。


(mySQL)
(mariaDB)

	OPTIMIZE TABLE テーブル名    -- インデックスを再編成します



(Oracle)

	ALTER INDEX インデックス名 REBUILD ONLINE; -- インデックスを再編成します



(postgleSQL)

	サービス停止できない場合:

		REINDEX インデックス名        -- インデックスを再編成します
			インデックスの元となるテーブルの書き込みをロックしますが、読み込みはロックしません。
			また、処理中のインデックスに対する排他ロックを取得するので、そのインデックスを使用する読み込みはブロックされる。


	サービス停止できない場合(PostgreSQL 9.1未満の場合):

		主キーインデックスではない場合:

			CREATE INDEX CONCURRENTLY インデックス名 ON テーブル名( フィールド名 );      -- 新規インデックスを作成します
			ALTER TABLE tbl                                                         -- テーブル構成を変更します
				DROP CONSTRAINT tbl_pkey,                                           -- 古いインデックスを削除します
				ADD PRIMARY KEY USING INDEX tbl_pkey_new;                           -- 新しいインデックスを追加します

		主キーインデックスの場合:

			不可



(SQLServer)

	まとまった時間が取れない場合:

		ALTER INDEX REORGANIZE               -- インデックスを再編成します

		キャンセル時点で処理が完了した部分については断片化が解消した状態が維持されます。ただし対象はインデックスのリーフレベルのみです。
		処理に割り当てられる時間が限られていて、処理を途中でキャンセルしなければならない可能性があるのであれば、再構築よりも再編成の方が、キャンセルした場合にもすべてが無駄にならず、毎日時間の許される範囲で実行するという方法を取ることがきます。


	まとまった時間が取れる場合:

		ALTER INDEX REBUILD                  -- インデックス全体を再構築します



(DB2)

	REORG INDEXES ALL FOR TABLE テーブル名                                            -- テーブル上に作成された索引をすべて再編成する
